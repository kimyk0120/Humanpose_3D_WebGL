<!DOCTYPE html>

<!--suppress ES6ModulesDependencies, JSUnresolvedVariable -->
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Humanpose 3D WebGL</title>
    <link rel="stylesheet" href="./css/Humanpose_3d_webGL.css">
    <script src="./js/three.js"></script>

</head>
<body>
    <script src="./js/Humanpose_3d_webGL.js"></script>
    <script>

        // init
        let width = window.innerWidth;
        let height = window.innerHeight;

        const renderer = new THREE.WebGLRenderer({antialias : true, alpha : true}); // 렌더러 정의 (antialias : 오브젝트 가장자리 정리)
        renderer.setSize(width, height);

        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene; // 씬 정의


        // Object
        let cubeGeometry = new THREE.CubeGeometry(100, 100, 100); // 너비, 높이, 깊이
        // MeshLambertMaterial: 조명 계산에 관한 람베르트의 알고리즘을 이용
        let cubeMaterial = new THREE.MeshLambertMaterial({ color: 0x1ec876 });
        let cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

        cube.rotation.y = Math.PI * 45 / 180; // 라디안

        scene.add(cube);


        // Camera
        // 45:  카메라의 위치에서 보여줄 각도(angle)인 FOV(시야)를 정의,
        //  카메라의 화면 종횡비를 정의 :  렌더러의 너비를 높이로 나눈 값
        // 0.1 , 10000 :  오브젝트가 카메라에 얼마나 가까워지고 멀어져서 그려질 수 있는지를 정의
        const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);

        camera.position.y = 200;
        camera.position.z = 400;
        camera.lookAt(cube.position);

        scene.add(camera);


        // lighting
        let skyboxGeometry = new THREE.CubeGeometry(10000, 10000, 10000);
        // 0x000000 : black, Three.js는 보통 바깥쪽 벽만 그리므로 THREE.BackSide(안쪽)
        let skyboxMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide });
        let skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);

        scene.add(skybox);

        let pointLight = new THREE.PointLight(0xffffff);
        pointLight.position.set(10, 250, 200);

        scene.add(pointLight);

        // 렌더링
        const clock = new THREE.Clock;

        //renderer.render(scene, camera);
        function render() {
            renderer.render(scene, camera);
            cube.rotation.y -= clock.getDelta();
            requestAnimationFrame(render);
        }

        render();
    </script>
</body>

</html>
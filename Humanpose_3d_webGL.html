<!DOCTYPE html>

<!--suppress ES6ModulesDependencies, JSUnresolvedVariable, SpellCheckingInspection, JSCheckFunctionSignatures, JSValidateJSDoc -->
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Humanpose 3D WebGL</title>
    <link rel="stylesheet" href="./css/Humanpose_3d_webGL.css">
</head>
<body>

    <div id="webgl_description">Humanpose 3D WebGL View</div>
    <div id="webgl_info"></div>
    <div id="webgl_output"></div>

    <script src="./js/three.min.js"></script> <!-- three.js   -->
    <script src="./js/WebGL.js"></script> <!-- browser support check-->
    <!-- OrbitControls.js allow the camera to orbit around a target 마우스와 카메라를 상호작용 -->
    <script src="./js/OrbitControls.js"></script>
    <script src="./js/FBXLoader.js"></script>
    <script src="./js/OBJLoader.js"></script>
    <script src="./js/inflate.min.js"></script>
    <script src="./js/stats.min.js"></script>


    <script>

        // init =======================================================================================================

        // Elements
        const webgl_description = document.getElementById("webgl_description");
        const webgl_info = document.getElementById("webgl_info");
        const webgl_output = document.getElementById("webgl_output");

        let camera, scene, renderer, light;
        const clock = new THREE.Clock;
        let perspective_max = 10000; // camera zoom max
        let perspective_min = 1; // camera zoom min
        let camera_angle = 45;
        let mixer, controls, stats; // libs
        let container; // webgl contatiner
        let model_opacity = 0.5;
        let mesh_data_path = "./data/fbx/BaseHuman.fbx"; // 3d model mesh data path
        let loader;// 3D model Loader var
        let file_ext = getExtension(mesh_data_path);
        if(file_ext[0] === 'fbx') loader = new THREE.FBXLoader();
        else if(file_ext[0] === 'obj') loader = new THREE.OBJLoader();
        else alert("지원하지 않는 3D 확장자입니다.");
        let keypoint_geometry, keypoint_material, keypoint_sphere_mesh; // keypoints mesh
        let model_object;

        // colors
        let scene_background_color = '#A0A0A0'; // #000000; black, #A0A0A0; gray
        let scene_fog_color = "#A0A0A0";
        let directionalLight_color = "#FFFFFF";
        let keypoint_color = "#FFFF00"; // #FFFF00;yellow, #FF0000; red

        // keypoints val init FIXME
        let keypoints_positions = [[0,175,0],[0,150,0],[20,145,0],[50,145,0],[70,145,0],
            [-20,145,0],[-50,145,0],[-70,145,0],[0,130,0],[0,95,0],[10,95,0],[-10,95,0],[-10,50,0],[10,50,0]
        ,[-8,10,0],[8,10,0]];

        //브라우저가 WebGL을 지원하는지 체크
        let webglBrowserCheckc_yn = webglBrowserCheck();
        if(!webglBrowserCheckc_yn){
            webgl_info.innerText = "이 브라우저는 WEBGL을 지원하지 않습니다.";
        }else{
            initThree();
            animate();
            keyPointInit();
        }


        // func =======================================================================================================

        /**
         * Threejs 초기화
         * @method initThree
         */
        function initThree() {

            // container
            container = webgl_output;

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(scene_background_color); // 0xa0a0a0
            scene.fog = new THREE.Fog(scene_fog_color, 200, 1000 );


            // light
            light = new THREE.DirectionalLight( directionalLight_color ); // 방향형 라이트
            light.position.set( 0, 200, -100);
            light.castShadow = true;
            scene.add( light );

            // light = new THREE.HemisphereLight(0xffffff, 0x444444 ); // 반구체형 라이트
            // light.position.set( 0, 200, 0 );
            // scene.add( light );

            // Camera
            /**
             * PerspectiveCamera(fov: Number, aspect: Number, near: Number, far: Number)
             * fov: 시야각 즉 3D 게임에서 한 화면에 어느 정도의 각도에서 보여줄지 설정
             * aspect: 화면 비율 즉 넓이를 높이로 나눈값
             * near: 렌더링이 수행되는 가까운점
             * far: 랜더링이 수행되는 가장 먼점
             */
            camera = new THREE.PerspectiveCamera(camera_angle, window.innerWidth / window.innerHeight, perspective_min, perspective_max);
            // camera.position.y = 200;
            // camera.position.z = 300;
            // camera.lookAt(axes.position);
            // scene.add(camera);
            camera.position.set(100 , 200 , 300);
            camera.lookAt(scene.position);

            // obj loader
            loader.load(mesh_data_path, function (object) {
                // 모델 로드가 완료되었을때 호출되는 함수
                // mixer = new THREE.AnimationMixer( object );
                // let action = mixer.clipAction( object.animations[ 0 ] );
                // action.play();

                // console.log(object);
                object.traverse( function ( child ) {
                    if ( child.isMesh ) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if(child.type==="SkinnedMesh"){
                            // console.log(child);
                            for (let i = 0; i < child.material.length ; i++) {
                                child.material[i].transparent = true;
                                child.material[i].opacity = model_opacity;
                            }
                        }
                    }
                } );

                scene.add(object);

                // skeleton helper
                // let helper = new THREE.SkeletonHelper(object);
                // scene.add(helper);

            }, function (xhr) {
                // 모델이 로드되는 동안 호출되는 함수
                let load_msg = Math.floor(xhr.loaded / xhr.total * 100) + '% loaded';
                console.log(xhr.loaded / xhr.total * 100, '% loaded');
                webgl_info.innerText = load_msg;
            }, function (error) {
                // 모델 로드가 실패했을 때 호출하는 함수
                console.log(error);
                webgl_info.innerText = "모델을 로드 중 오류가 발생하였습니다.";
            });

            // renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true, alpha: true
            });
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Percentage-Closer Filtering 알고리즘
            //document.body.appendChild(renderer.domElement);
            container.appendChild(renderer.domElement);

            /**
             * scene 화면상에 XYZ(Red: X, Green: Y, Blue: Z) 축
             * AxisHelper(size : Number)
             * size: optional 축의 크기, 기본값은 1.
             */
            let axes = new THREE.AxesHelper(10);
            scene.add(axes);


            // Orbit Controls
            controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.target.set( 0, 100, 0 );
            controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 100;
            controls.maxDistance = 500;
            // controls.maxPolarAngle = Math.PI / 2;
            controls.update();

            window.addEventListener( 'resize', onWindowResize, false );

            // stats
            stats = new Stats();
            container.appendChild( stats.dom );
        }

        /**
         * window resize
         * @method onWindowResize
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }

        /**
         * call renderer
         * @method animate
         */
        function animate() {
            requestAnimationFrame(animate);// like settimeout , Interval은 브라우저에 의해 정해짐
            let delta = clock.getDelta();
            if ( mixer ) mixer.update( delta );
            renderer.render( scene, camera );
            stats.update();
        }

        /**
         * get extension
         * @param filename
         * @returns {any}
         */
        function getExtension(filename){
            return (/[.]/.exec(filename)) ? /[^.]+$/.exec(filename) : undefined;
        }

        /**
         * keypoints init FIXME
         * @method keyPointInit
         */
        function keyPointInit(){
            for (let i = 0; i < keypoints_positions.length ; i++) {
                keypoint_geometry = new THREE.SphereGeometry( 3, 16, 16 ); // radius , w_segments, h_w_segments
                keypoint_material = new THREE.MeshLambertMaterial( {color: keypoint_color} );
                keypoint_sphere_mesh = new THREE.Mesh( keypoint_geometry, keypoint_material );
                keypoint_sphere_mesh.name = "test"+i;
                // console.log(keypoints_positions[0]);
                keypoint_sphere_mesh.position.set(keypoints_positions[i][0],keypoints_positions[i][1],keypoints_positions[i][2]);
                scene.add( keypoint_sphere_mesh );
            }
        }

        /**
         * move keypoint
         * @param key_name
         * @param x
         * @param y
         * @param z
         */
        function moveKeypoint(key_name, x, y, z){
            //console.log(scene.children);
            for (let i = 0; i < scene.children.length ; i++) {
                if(scene.children[i].type === "Mesh" && scene.children[i].name === key_name){
                    scene.children[i].translateX(x);
                    scene.children[i].translateY(y);
                    scene.children[i].translateZ(z);
                }
            }
        }

    </script>
</body>

</html>